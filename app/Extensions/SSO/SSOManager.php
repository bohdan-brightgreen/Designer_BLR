<?phpnamespace SSO;use \Illuminate\Encryption\Encrypter;use Illuminate\Contracts\Encryption\DecryptException;class SSOManager{    /**     * @var  array  SSO configuration     */    protected $app;    /**     * @var  \Illuminate\Encryption\Encrypter  Encrypter class     */    protected $Encrypter;    /**     * SSOManager constructor     *     * @param  array  $app  Application configuration     */    public function __construct($app)    {        $this->app = $app['config']['sso'];        $this->Encrypter = new Encrypter($this->app['secret'], 'AES-256-CBC');    }    /**     * Return URL of SSO service     *     * @return string  URL of SSO     */    public function getSSOUrl()    {	   return $this->app['url'] . '/sso/' . $this->createToken();    }    /**     * Return URL of SSO logout service     *     * @return string  URL of SSO logout     */    public function logoutUrl()    {        return $this->app['url'] . '/auth/logout';    }    /**     * Encrypt a value     *     * @param  mixed  $value  Value to encrypt     * @return string  Encrypted string     */    public function encrypt($value)    {        return $this->Encrypter->encrypt($value);    }    /**     * Decrypt a string     *     * @param  string  $string  String to decrypt     * @return bool|mixed  Decrypted value if success     */    public function decrypt($string)    {        try {            return $this->Encrypter->decrypt($string);        } catch (DecryptException $e) {            return false;        }    }    /**     * Generate encrypted SSO token     *     * @return string  SSO token     */    public function createToken()    {        $token = str_random(100);        session(['requestToken' => $token]);        $clientId = (string) $this->app['clientId'];        $payload = [            'client' => $clientId,            'token' => $token,            'url' => request()->url(),            'timestamp' => time()        ];        return $clientId . '.' . $this->encrypt($payload);    }    /**     * Check if provided data is valid     *     * @param  mixed|array  $data  Data to validate     * @return bool     */    public function validate($data)    {        $now = time();        return (            is_array($data) &&            isset($data['client']) &&            isset($data['token']) &&            isset($data['timestamp']) &&            isset($data['session']) &&            ($data['client'] === $this->app['clientId']) &&            ($data['token'] === session('requestToken')) &&            ($data['timestamp'] <= $now) &&            ($data['timestamp'] >= ($now - $this->app['responseTimeLimit']))        );    }    /**     * Check token and apply if valid     *     * @param  string  $token  Token to set     * @return array|bool  URL to redirect if token is valid, otherwise false     */    public function set($token)    {        $data = $this->decrypt($token);        if ($data === false ||            !$this->validate($data)        ) {            return false;        }        session()->regenerate(true);        $this->setSessionId($data['session']);        if (!$this->authUser()) {            return false;        }        $this->setSessionId($data['session']);        return $data['url'];    }    /**     * Authorize a user in the system     *     * @return bool     */    public function authUser()    {        auth()->logout();        $user = session('user');        if (empty($user['id'])) {            return false;        }        auth()->loginUsingId($user['id']);        return true;    }    /**     * Set session ID     *     * @param  string  $sessionId  Session ID to set     */    public function setSessionId($sessionId)    {        session()->setId($sessionId);        session()->start();    }}